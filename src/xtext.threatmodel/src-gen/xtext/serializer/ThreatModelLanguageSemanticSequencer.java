/*
 * generated by Xtext 2.33.0
 */
package xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.services.ThreatModelLanguageGrammarAccess;
import xtext.threatModelLanguage.AddBoundary;
import xtext.threatModelLanguage.AddDatastore;
import xtext.threatModelLanguage.AddExternal;
import xtext.threatModelLanguage.AddFlow;
import xtext.threatModelLanguage.AddProcess;
import xtext.threatModelLanguage.BoundaryAddEntity;
import xtext.threatModelLanguage.BoundaryRemoveEntity;
import xtext.threatModelLanguage.ChangeDescription;
import xtext.threatModelLanguage.Countermeasure;
import xtext.threatModelLanguage.Design;
import xtext.threatModelLanguage.FlowDestination;
import xtext.threatModelLanguage.FlowFix;
import xtext.threatModelLanguage.FlowSource;
import xtext.threatModelLanguage.MergeIntoDatastore;
import xtext.threatModelLanguage.MergeIntoExternal;
import xtext.threatModelLanguage.MergeIntoProcess;
import xtext.threatModelLanguage.Model;
import xtext.threatModelLanguage.ReID;
import xtext.threatModelLanguage.Refactoring;
import xtext.threatModelLanguage.Remove;
import xtext.threatModelLanguage.Rename;
import xtext.threatModelLanguage.RotateFlow;
import xtext.threatModelLanguage.Sketching;
import xtext.threatModelLanguage.SplitDatastoreAndDatastore;
import xtext.threatModelLanguage.SplitDatastoreAndExternal;
import xtext.threatModelLanguage.SplitExternalAndDatastore;
import xtext.threatModelLanguage.SplitExternalAndExternal;
import xtext.threatModelLanguage.SplitExternalAndProcess;
import xtext.threatModelLanguage.SplitProcessAndExternal;
import xtext.threatModelLanguage.SplitProcessAndProcess;
import xtext.threatModelLanguage.SplitsDatastoreAndProcess;
import xtext.threatModelLanguage.SplitsProcessAndDatastore;
import xtext.threatModelLanguage.Testing;
import xtext.threatModelLanguage.ThreatModelLanguagePackage;

@SuppressWarnings("all")
public class ThreatModelLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ThreatModelLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ThreatModelLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ThreatModelLanguagePackage.ADD_BOUNDARY:
				sequence_AddBoundary(context, (AddBoundary) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.ADD_DATASTORE:
				sequence_AddDatastore(context, (AddDatastore) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.ADD_EXTERNAL:
				sequence_AddExternal(context, (AddExternal) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.ADD_FLOW:
				sequence_AddFlow(context, (AddFlow) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.ADD_PROCESS:
				sequence_AddProcess(context, (AddProcess) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.BOUNDARY_ADD_ENTITY:
				sequence_BoundaryAddEntity(context, (BoundaryAddEntity) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.BOUNDARY_REMOVE_ENTITY:
				sequence_BoundaryRemoveEntity(context, (BoundaryRemoveEntity) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.CHANGE_DESCRIPTION:
				sequence_ChangeDescription(context, (ChangeDescription) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.COUNTERMEASURE:
				sequence_Countermeasure(context, (Countermeasure) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.DESIGN:
				sequence_Design(context, (Design) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.FLOW_DESTINATION:
				sequence_FlowDestination(context, (FlowDestination) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.FLOW_FIX:
				sequence_FlowFix(context, (FlowFix) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.FLOW_SOURCE:
				sequence_FlowSource(context, (FlowSource) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.MERGE_INTO_DATASTORE:
				sequence_MergeIntoDatastore(context, (MergeIntoDatastore) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.MERGE_INTO_EXTERNAL:
				sequence_MergeIntoExternal(context, (MergeIntoExternal) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.MERGE_INTO_PROCESS:
				sequence_MergeIntoProcess(context, (MergeIntoProcess) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.RE_ID:
				sequence_ReID(context, (ReID) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.REFACTORING:
				sequence_Refactoring(context, (Refactoring) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.REMOVE:
				sequence_Remove(context, (Remove) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.RENAME:
				sequence_Rename(context, (Rename) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.ROTATE_FLOW:
				sequence_RotateFlow(context, (RotateFlow) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.SKETCHING:
				sequence_Sketching(context, (Sketching) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.SPLIT_DATASTORE_AND_DATASTORE:
				sequence_SplitDatastoreAndDatastore(context, (SplitDatastoreAndDatastore) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.SPLIT_DATASTORE_AND_EXTERNAL:
				sequence_SplitDatastoreAndExternal(context, (SplitDatastoreAndExternal) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.SPLIT_EXTERNAL_AND_DATASTORE:
				sequence_SplitExternalAndDatastore(context, (SplitExternalAndDatastore) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.SPLIT_EXTERNAL_AND_EXTERNAL:
				sequence_SplitExternalAndExternal(context, (SplitExternalAndExternal) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.SPLIT_EXTERNAL_AND_PROCESS:
				sequence_SplitExternalAndProcess(context, (SplitExternalAndProcess) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.SPLIT_PROCESS_AND_EXTERNAL:
				sequence_SplitProcessAndExternal(context, (SplitProcessAndExternal) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.SPLIT_PROCESS_AND_PROCESS:
				sequence_SplitProcessAndProcess(context, (SplitProcessAndProcess) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.SPLITS_DATASTORE_AND_PROCESS:
				sequence_SplitsDatastoreAndProcess(context, (SplitsDatastoreAndProcess) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.SPLITS_PROCESS_AND_DATASTORE:
				sequence_SplitsProcessAndDatastore(context, (SplitsProcessAndDatastore) semanticObject); 
				return; 
			case ThreatModelLanguagePackage.TESTING:
				sequence_Testing(context, (Testing) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns AddBoundary
	 *     Operations returns AddBoundary
	 *     Add returns AddBoundary
	 *     AddBoundary returns AddBoundary
	 *
	 * Constraint:
	 *     (id=ID name=STRING? description=STRING? entities+=ID* documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_AddBoundary(ISerializationContext context, AddBoundary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns AddDatastore
	 *     Operations returns AddDatastore
	 *     Add returns AddDatastore
	 *     AddEntity returns AddDatastore
	 *     AddDatastore returns AddDatastore
	 *
	 * Constraint:
	 *     (id=ID name=STRING? description=STRING? documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_AddDatastore(ISerializationContext context, AddDatastore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns AddExternal
	 *     Operations returns AddExternal
	 *     Add returns AddExternal
	 *     AddEntity returns AddExternal
	 *     AddExternal returns AddExternal
	 *
	 * Constraint:
	 *     (id=ID name=STRING? description=STRING? documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_AddExternal(ISerializationContext context, AddExternal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns AddFlow
	 *     Operations returns AddFlow
	 *     Add returns AddFlow
	 *     AddFlow returns AddFlow
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         name=STRING? 
	 *         description=STRING? 
	 *         sourceId=ID 
	 *         destinationId=ID 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_AddFlow(ISerializationContext context, AddFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns AddProcess
	 *     Operations returns AddProcess
	 *     Add returns AddProcess
	 *     AddEntity returns AddProcess
	 *     AddProcess returns AddProcess
	 *
	 * Constraint:
	 *     (id=ID name=STRING? description=STRING? documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_AddProcess(ISerializationContext context, AddProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns BoundaryAddEntity
	 *     Operations returns BoundaryAddEntity
	 *     Modify returns BoundaryAddEntity
	 *     BoundaryAddEntity returns BoundaryAddEntity
	 *
	 * Constraint:
	 *     (id=ID newEntity=ID documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_BoundaryAddEntity(ISerializationContext context, BoundaryAddEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns BoundaryRemoveEntity
	 *     Operations returns BoundaryRemoveEntity
	 *     Modify returns BoundaryRemoveEntity
	 *     BoundaryRemoveEntity returns BoundaryRemoveEntity
	 *
	 * Constraint:
	 *     (id=ID oldEntity=ID documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_BoundaryRemoveEntity(ISerializationContext context, BoundaryRemoveEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns ChangeDescription
	 *     Operations returns ChangeDescription
	 *     Modify returns ChangeDescription
	 *     ChangeDescription returns ChangeDescription
	 *
	 * Constraint:
	 *     (id=ID description=STRING documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_ChangeDescription(ISerializationContext context, ChangeDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns Countermeasure
	 *     Grouping returns Countermeasure
	 *     Countermeasure returns Countermeasure
	 *
	 * Constraint:
	 *     (name=ID description=STRING operatoins+=Operations*)
	 * </pre>
	 */
	protected void sequence_Countermeasure(ISerializationContext context, Countermeasure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns Design
	 *     Grouping returns Design
	 *     Design returns Design
	 *
	 * Constraint:
	 *     (name=ID description=STRING operatoins+=Operations*)
	 * </pre>
	 */
	protected void sequence_Design(ISerializationContext context, Design semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns FlowDestination
	 *     Operations returns FlowDestination
	 *     Modify returns FlowDestination
	 *     FlowDestination returns FlowDestination
	 *
	 * Constraint:
	 *     (id=ID destination=ID documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_FlowDestination(ISerializationContext context, FlowDestination semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FlowFix returns FlowFix
	 *
	 * Constraint:
	 *     (flowId=ID entityId=ID)
	 * </pre>
	 */
	protected void sequence_FlowFix(ISerializationContext context, FlowFix semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThreatModelLanguagePackage.Literals.FLOW_FIX__FLOW_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThreatModelLanguagePackage.Literals.FLOW_FIX__FLOW_ID));
			if (transientValues.isValueTransient(semanticObject, ThreatModelLanguagePackage.Literals.FLOW_FIX__ENTITY_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThreatModelLanguagePackage.Literals.FLOW_FIX__ENTITY_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFlowFixAccess().getFlowIdIDTerminalRuleCall_0_0(), semanticObject.getFlowId());
		feeder.accept(grammarAccess.getFlowFixAccess().getEntityIdIDTerminalRuleCall_2_0(), semanticObject.getEntityId());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns FlowSource
	 *     Operations returns FlowSource
	 *     Modify returns FlowSource
	 *     FlowSource returns FlowSource
	 *
	 * Constraint:
	 *     (id=ID source=ID documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_FlowSource(ISerializationContext context, FlowSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns MergeIntoDatastore
	 *     Operations returns MergeIntoDatastore
	 *     Modify returns MergeIntoDatastore
	 *     MergeEntity returns MergeIntoDatastore
	 *     MergeIntoDatastore returns MergeIntoDatastore
	 *
	 * Constraint:
	 *     (
	 *         entity1=ID 
	 *         entity2=ID 
	 *         id=ID 
	 *         name=STRING? 
	 *         description=STRING? 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_MergeIntoDatastore(ISerializationContext context, MergeIntoDatastore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns MergeIntoExternal
	 *     Operations returns MergeIntoExternal
	 *     Modify returns MergeIntoExternal
	 *     MergeEntity returns MergeIntoExternal
	 *     MergeIntoExternal returns MergeIntoExternal
	 *
	 * Constraint:
	 *     (
	 *         entity1=ID 
	 *         entity2=ID 
	 *         id=ID 
	 *         name=STRING? 
	 *         description=STRING? 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_MergeIntoExternal(ISerializationContext context, MergeIntoExternal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns MergeIntoProcess
	 *     Operations returns MergeIntoProcess
	 *     Modify returns MergeIntoProcess
	 *     MergeEntity returns MergeIntoProcess
	 *     MergeIntoProcess returns MergeIntoProcess
	 *
	 * Constraint:
	 *     (
	 *         entity1=ID 
	 *         entity2=ID 
	 *         id=ID 
	 *         name=STRING? 
	 *         description=STRING? 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_MergeIntoProcess(ISerializationContext context, MergeIntoProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     elements+=Statements+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns ReID
	 *     Operations returns ReID
	 *     Modify returns ReID
	 *     ReID returns ReID
	 *
	 * Constraint:
	 *     (id=ID newId=ID documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_ReID(ISerializationContext context, ReID semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns Refactoring
	 *     Grouping returns Refactoring
	 *     Refactoring returns Refactoring
	 *
	 * Constraint:
	 *     (name=ID description=STRING operatoins+=Operations*)
	 * </pre>
	 */
	protected void sequence_Refactoring(ISerializationContext context, Refactoring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns Remove
	 *     Operations returns Remove
	 *     Remove returns Remove
	 *
	 * Constraint:
	 *     (id=ID documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_Remove(ISerializationContext context, Remove semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns Rename
	 *     Operations returns Rename
	 *     Modify returns Rename
	 *     Rename returns Rename
	 *
	 * Constraint:
	 *     (id=ID newName=STRING documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_Rename(ISerializationContext context, Rename semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns RotateFlow
	 *     Operations returns RotateFlow
	 *     Modify returns RotateFlow
	 *     RotateFlow returns RotateFlow
	 *
	 * Constraint:
	 *     (id=ID documentation=STRING?)
	 * </pre>
	 */
	protected void sequence_RotateFlow(ISerializationContext context, RotateFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sketching returns Sketching
	 *
	 * Constraint:
	 *     (name=ID description=STRING operatoins+=Operations*)
	 * </pre>
	 */
	protected void sequence_Sketching(ISerializationContext context, Sketching semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns SplitDatastoreAndDatastore
	 *     Operations returns SplitDatastoreAndDatastore
	 *     Modify returns SplitDatastoreAndDatastore
	 *     SplitEntity returns SplitDatastoreAndDatastore
	 *     SplitDatastoreAndDatastore returns SplitDatastoreAndDatastore
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         entity1=ID 
	 *         entity1Name=STRING? 
	 *         entity1Description=STRING? 
	 *         entity2=ID 
	 *         entity2Name=STRING? 
	 *         entity2Description=STRING? 
	 *         flowFix+=FlowFix* 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_SplitDatastoreAndDatastore(ISerializationContext context, SplitDatastoreAndDatastore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns SplitDatastoreAndExternal
	 *     Operations returns SplitDatastoreAndExternal
	 *     Modify returns SplitDatastoreAndExternal
	 *     SplitEntity returns SplitDatastoreAndExternal
	 *     SplitDatastoreAndExternal returns SplitDatastoreAndExternal
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         entity1=ID 
	 *         entity1Name=STRING? 
	 *         entity1Description=STRING? 
	 *         entity2=ID 
	 *         entity2Name=STRING? 
	 *         entity2Description=STRING? 
	 *         flowFix+=FlowFix* 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_SplitDatastoreAndExternal(ISerializationContext context, SplitDatastoreAndExternal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns SplitExternalAndDatastore
	 *     Operations returns SplitExternalAndDatastore
	 *     Modify returns SplitExternalAndDatastore
	 *     SplitEntity returns SplitExternalAndDatastore
	 *     SplitExternalAndDatastore returns SplitExternalAndDatastore
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         entity1=ID 
	 *         entity1Name=STRING? 
	 *         entity1Description=STRING? 
	 *         entity2=ID 
	 *         entity2Name=STRING? 
	 *         entity2Description=STRING? 
	 *         flowFix+=FlowFix* 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_SplitExternalAndDatastore(ISerializationContext context, SplitExternalAndDatastore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns SplitExternalAndExternal
	 *     Operations returns SplitExternalAndExternal
	 *     Modify returns SplitExternalAndExternal
	 *     SplitEntity returns SplitExternalAndExternal
	 *     SplitExternalAndExternal returns SplitExternalAndExternal
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         entity1=ID 
	 *         entity1Name=STRING? 
	 *         entity1Description=STRING? 
	 *         entity2=ID 
	 *         entity2Name=STRING? 
	 *         entity2Description=STRING? 
	 *         flowFix+=FlowFix* 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_SplitExternalAndExternal(ISerializationContext context, SplitExternalAndExternal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns SplitExternalAndProcess
	 *     Operations returns SplitExternalAndProcess
	 *     Modify returns SplitExternalAndProcess
	 *     SplitEntity returns SplitExternalAndProcess
	 *     SplitExternalAndProcess returns SplitExternalAndProcess
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         entity1=ID 
	 *         entity1Name=STRING? 
	 *         entity1Description=STRING? 
	 *         entity2=ID 
	 *         entity2Name=STRING? 
	 *         entity2Description=STRING? 
	 *         flowFix+=FlowFix* 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_SplitExternalAndProcess(ISerializationContext context, SplitExternalAndProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns SplitProcessAndExternal
	 *     Operations returns SplitProcessAndExternal
	 *     Modify returns SplitProcessAndExternal
	 *     SplitEntity returns SplitProcessAndExternal
	 *     SplitProcessAndExternal returns SplitProcessAndExternal
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         entity1=ID 
	 *         entity1Name=STRING? 
	 *         entity1Description=STRING? 
	 *         entity2=ID 
	 *         entity2Name=STRING? 
	 *         entity2Description=STRING? 
	 *         flowFix+=FlowFix* 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_SplitProcessAndExternal(ISerializationContext context, SplitProcessAndExternal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns SplitProcessAndProcess
	 *     Operations returns SplitProcessAndProcess
	 *     Modify returns SplitProcessAndProcess
	 *     SplitEntity returns SplitProcessAndProcess
	 *     SplitProcessAndProcess returns SplitProcessAndProcess
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         entity1=ID 
	 *         entity1Name=STRING? 
	 *         entity1Description=STRING? 
	 *         entity2=ID 
	 *         entity2Name=STRING? 
	 *         entity2Description=STRING? 
	 *         flowFix+=FlowFix* 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_SplitProcessAndProcess(ISerializationContext context, SplitProcessAndProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns SplitsDatastoreAndProcess
	 *     Operations returns SplitsDatastoreAndProcess
	 *     Modify returns SplitsDatastoreAndProcess
	 *     SplitEntity returns SplitsDatastoreAndProcess
	 *     SplitsDatastoreAndProcess returns SplitsDatastoreAndProcess
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         entity1=ID 
	 *         entity1Name=STRING? 
	 *         entity1Description=STRING? 
	 *         entity2=ID 
	 *         entity2Name=STRING? 
	 *         entity2Description=STRING? 
	 *         flowFix+=FlowFix* 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_SplitsDatastoreAndProcess(ISerializationContext context, SplitsDatastoreAndProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statements returns SplitsProcessAndDatastore
	 *     Operations returns SplitsProcessAndDatastore
	 *     Modify returns SplitsProcessAndDatastore
	 *     SplitEntity returns SplitsProcessAndDatastore
	 *     SplitsProcessAndDatastore returns SplitsProcessAndDatastore
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         entity1=ID 
	 *         entity1Name=STRING? 
	 *         entity1Description=STRING? 
	 *         entity2=ID 
	 *         entity2Name=STRING? 
	 *         entity2Description=STRING? 
	 *         flowFix+=FlowFix* 
	 *         documentation=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_SplitsProcessAndDatastore(ISerializationContext context, SplitsProcessAndDatastore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Testing returns Testing
	 *
	 * Constraint:
	 *     (name=ID description=STRING operatoins+=Operations*)
	 * </pre>
	 */
	protected void sequence_Testing(ISerializationContext context, Testing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
